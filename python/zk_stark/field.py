from __future__ import annotations
from utils import find_prime_divisors, is_prime

# Use extended Euclidean algo for calculating multiplicative inverse
# TODO: wat dis?
def xgcd(x: int, y: int) -> (int, int, int):
    old_r, r = (x, y)
    old_s, s = (1, 0)
    old_t, t = (0, 1)

    while r != 0:
        quotient = old_r // r
        old_r, r = (r, old_r - quotient * r)
        old_s, s = (s, old_s - quotient * s)
        old_t, t = (t, old_t - quotient * t)

    return old_s, old_t, old_r # a, b, g


# Must be a prime field with subgroup of power of 2 order
# P = 1 + 407 * (1 << 119)
P = (1 << 4) + 1

# Field
class F:
    def __init__(self, v: int, p: int = P):
        self.v = v % p
        self.p = p

    def wrap(self, v: int) -> F:
        return F(v, self.p)

    def inv(self) -> F:
        a, _, _ = xgcd(self.v, self.p)
        return self.wrap(a)

    def _check(self, x: F):
        assert self.p == x.p

    def __add__(self, x: F):
        self._check(x)
        return self.wrap((self.v + x.v) % self.p)

    def __sub__(self, x: F):
        self._check(x)
        return self.wrap((self.v - x.v) % self.p)

    def __mul__(self, x: F):
        self._check(x)
        return self.wrap((self.v * x.v) % self.p)

    def __truediv__(self, x: F):
        self._check(x)
        assert x.v != 0, "div by 0"
        return self * x.inv()

    def __pow__(self, exp: int):
        if exp == 0:
            return self.wrap(1)
        
        if exp < 0:
            return self.inv() ** (-exp)

        return self.wrap(pow(self.v, exp, self.p))
        
        # Fast exponentiation (square and multiply)
        # y = self.wrap(1)
        # base = self.wrap(self.v)
        
        # while exp > 0:
        #     if exp % 2 == 1:
        #         y *= base
        #     base *= base
        #     exp //= 2
        
        # return y

    def __eq__(self, x):
        self._check(x)
        return (self.v % self.p) == (x.v % self.p)

    def __neq__(self, x):
        self._check(x)
        return (self.v % self.p) != (x.v % self.p)

    def __neg__(self):
        return self.wrap((self.p - self.v) % self.p)

    def __str__(self):
        return str(self.v)

    def __repr__(self):
        return str(self.v)

Z = F(0)

def find_generator(p: int) -> int | None:
    """
    g is a generator of Fp, p prime, iff
    g^((p-1) / q) != 1 mod p
    for all q, prime divisors of p - 1
    """
    divs = find_prime_divisors(p - 1)
    for x in range(1, p):
        if all(pow(x, (p - 1) // q, p) != 1 for q in divs):
            return x
    return None

def check_generator(g: int, p: int):
    """
    Check order of the group generated by g, should be p - 1
    """
    group = set()
    for i in range(0, p - 1):
        x = pow(g, i, p)
        assert x not in group, f'{x} = {g}^{i} is already included'
        group.add(x)
    assert len(group) == p - 1, f'Order of group generated by g = {g}: {len(group)}'

# Nth primitive root of unity
def get_primitive_root(g: int, p: int, n: int) -> int:
    w = pow(g, (p - 1) // n, p)
    # Check r is a primitive Nth root
    for i in range(1, n):
        x = pow(w, i, p)
        # print(f'{w}^{i} = {x}')
        assert x != 1
    assert pow(w, n, p) == 1
    return w
    