from __future__ import annotations
from utils import find_prime_divisors

# Use extended Euclidean algo for calculating multiplicative inverse
# TODO: wat dis?
def xgcd(x: int, y: int) -> (int, int, int):
    old_r, r = (x, y)
    old_s, s = (1, 0)
    old_t, t = (0, 1)

    while r != 0:
        quotient = old_r // r
        old_r, r = (r, old_r - quotient * r)
        old_s, s = (s, old_s - quotient * s)
        old_t, t = (t, old_t - quotient * t)

    return old_s, old_t, old_r # a, b, g

# Field
class F:
    def __init__(self, v: int, p: int):
        self.v = v % p
        self.p = p

    def wrap(self, v: int) -> F:
        return F(v, self.p)

    def inv(self) -> F:
        a, _, _ = xgcd(self.v, self.p)
        return self.wrap(a)

    def check(self, x: int | F) -> F:
        if isinstance(x, int):
            return F(x, self.p)
        assert self.p == x.p
        return x

    # F + (int | F)
    def __add__(self, x: int | F) -> F:
        x = self.check(x)
        return self.wrap((self.v + x.v) % self.p)

    # (int | F) + F
    def __radd__(self, x: int | F) -> F:
        # Addition is commutative
        return self.__add__(x)

    # F - (int | F)
    def __sub__(self, x: int | F) -> F:
        x = self.check(x)
        return self.wrap((self.v - x.v) % self.p)

    # (int | F) - F
    def __rsub__(self, x: int | F) -> F:
        x = self.check(x)
        return x.__sub__(self)

    # F * (int | F)
    def __mul__(self, x: int | F) -> F:
        x = self.check(x)
        return self.wrap((self.v * x.v) % self.p)

    # (int | F) * F
    def __rmul__(self, x: int | F) -> F:
        # Multiplication is commutative
        return self.__mul__(x)

    # F / (int | F)
    def __truediv__(self, x: int | F) -> F:
        x = self.check(x)
        assert x.v != 0, "div by 0"
        return self * x.inv()

    # (int | F) / F
    def __rtruediv__(self, x):
        x = self.check(x)
        return x.__truediv__(self)

    # F**int
    def __pow__(self, exp: int) -> F:
        if exp == 0:
            return self.wrap(1)
        
        if exp < 0:
            return self.inv() ** (-exp)

        return self.wrap(pow(self.v, exp, self.p))

    def __eq__(self, x: int | F):
        x = self.check(x)
        return (self.v % self.p) == (x.v % self.p)

    def __neq__(self, x: int | F):
        x = self.check(x)
        return (self.v % self.p) != (x.v % self.p)

    def __neg__(self):
        return self.wrap((self.p - self.v) % self.p)

    def __str__(self):
        return str(self.v)

    def __repr__(self):
        return str(self.v)

def find_generator(p: int) -> int | None:
    # Generator g is an element in F[P], finite field mod P, such that
    # {g^0, g^1, ..., g^(P-1)} mod P = {1, 2, 3, ..., P - 1} mod P

    # Fast way to find g
    # g is a generator of F[P], P prime, iff
    # g^((P-1) / q) != 1 mod P
    # for all q, prime divisors of P - 1

    divs = find_prime_divisors(p - 1)
    for x in range(1, p):
        if all(pow(x, (p - 1) // q, p) != 1 for q in divs):
            return x
    return None

def check_generator(g: int, p: int):
    """
    Check order of the group generated by g, should be p - 1
    """
    group = {1}
    for i in range(1, p - 1):
        x = pow(g, i, p)
        assert x not in group, f'{x} = {g}^{i} is already included'
        group.add(x)
    assert len(group) == p - 1, f'Order of group generated by g = {g}: {len(group)}'

# Nth primitive root of unity
def get_primitive_root(g: int, p: int, n: int, check = True) -> int:
    w = pow(g, (p - 1) // n, p)
    # Check w is a primitive Nth root
    if check:
        s = {1}
        for i in range(1, n):
            x = pow(w, i, p)
            # print(f'{w}^{i} = {x}')
            assert x != 1
            assert x not in s
            s.add(x)
        # Check w**n = 1
        assert pow(w, n, p) == 1
        # Check w**(n/2) = -1
        if n % 2 == 0:
            assert pow(w, n // 2, p) == (-1 % p)
    return w
